
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

#include <string.h>
#include <stdlib.h>

#define EXTRA_BYTES 256
#define BLOCK_SIZE 128
#define BUF_SIZE 256

struct header {
    uint64_t size;
    struct header *next;
};

void handle_error(const char *msg) { write(2, msg, strlen(msg)); exit(1);


void print_out(char *format, void *data, size_t data_size) {
    char buf[BUF_SIZE];
    int len = snprintf(buf, BUF_SIZE, format,
                      data_size == sizeof(uint64_t) ? *(uint64_t *)data
                                                    : *(void **)data);
    write(STDOUT_FILENO, buf, len);
}

int main(void) {
    void *start = sbrk(EXTRA_BYTES);
    if (start == (void *)-1) handle_error("sbrk failed");

    struct header *first = (struct header *)start;
    struct header *second = (struct header *)((char *)start + BLOCK_SIZE);

    first->size = BLOCK_SIZE;
    first->next = NULL;
    second->size = BLOCK_SIZE;
    second->next = first;

    print_out("first block:       %p\n", &first, sizeof(first));
    print_out("second block:      %p\n", &second, sizeof(second));
    print_out("first block size:  %llu\n", &first->size, sizeof(uint64_t));
    print_out("first block next:  %p\n", &first->next, sizeof(first->next));
    print_out("second block size: %llu\n", &second->size, sizeof(uint64_t));
    print_out("second block next: %p\n", &second->next, sizeof(second->next));

    size_t data_len = BLOCK_SIZE - sizeof(struct header);
    void *first_data = (char *)first + sizeof(struct header);
    void *second_data = (char *)second + sizeof(struct header);

    memset(first_data, 0, data_len);
    memset(second_data, 1, data_len);

    unsigned char *p;
    for (p = first_data; p < (unsigned char *)first_data + data_len; p++)
        dprintf(STDOUT_FILENO, "%u\n", *p);
    for (p = second_data; p < (unsigned char *)second_data + data_len; p++)
        dprintf(STDOUT_FILENO, "%u\n", *p);

    return 0;
}

